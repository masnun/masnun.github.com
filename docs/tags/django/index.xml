<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>masnun.rocks()</title>
    <link>http://masnun.rocks/tags/django/index.xml</link>
    <description>Recent content on masnun.rocks()</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://masnun.rocks/tags/django/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Django Admin: Expensive COUNT(*) Queries</title>
      <link>http://masnun.rocks/2017/03/20/django-admin-expensive-count-all-queries/</link>
      <pubDate>Mon, 20 Mar 2017 22:43:59 +0600</pubDate>
      
      <guid>http://masnun.rocks/2017/03/20/django-admin-expensive-count-all-queries/</guid>
      <description>

&lt;p&gt;If you are a Django developer, it is very likely that you use the Django Admin regularly. And if you have maintained a website with a huge amount of data, you probably already know that Django Admin can become very slow when the database table gets so large. If you log the SQL queries (either using Django logging or using Django Debug Toolbar), you would notice a very expensive
SQL query, something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;SELECT COUNT(*) AS &amp;quot;__count&amp;quot; FROM &amp;quot;table_name&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the default settings, you will actually notice this query twice. If you use Django Debug Toolbar, it will tell you that the query was duplicated 2 times.&lt;/p&gt;

&lt;h3 id=&#34;issue-1&#34;&gt;Issue - 1&lt;/h3&gt;

&lt;p&gt;By default &lt;code&gt;ModelAdmin&lt;/code&gt; has &lt;code&gt;show_full_result_count = True&lt;/code&gt; which shows the full result count in the admin interface. This is the source of one of the &lt;code&gt;count(*)&lt;/code&gt; queries.&lt;/p&gt;

&lt;p&gt;To fix that, we just need to set this on our &lt;code&gt;ModelAdmin&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;show_full_result_count = False
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;issue-2&#34;&gt;Issue - 2&lt;/h3&gt;

&lt;p&gt;Even after switching &lt;code&gt;show_full_result_count&lt;/code&gt; off, we are still noticing a &lt;code&gt;count(*)&lt;/code&gt; query in the log. It&amp;rsquo;s because the Django Paginator does a count itself.&lt;/p&gt;

&lt;p&gt;The solution is to somehow bypass the expensive query while still returning a number so the pagination works as expected. We can cache the count value or even run raw SQL query find an approximate value through a rather inexpensive lookup somewhere else.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a quick example of a paginator that runs the expensive query once and then caches the results:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;from django.core.paginator import Paginator
from django.core.cache import cache

# Modified version of a GIST I found in a SO thread
class CachingPaginator(Paginator):
    def _get_count(self):

        if not hasattr(self, &amp;quot;_count&amp;quot;):
            self._count = None

        if self._count is None:
            try:
                key = &amp;quot;adm:{0}:count&amp;quot;.format(hash(self.object_list.query.__str__()))
                self._count = cache.get(key, -1)
                if self._count == -1:
                    self._count = super().count
                    cache.set(key, self._count, 3600)

            except:
                self._count = len(self.object_list)
        return self._count

    count = property(_get_count)

    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now on our &lt;code&gt;ModelAdmin&lt;/code&gt; we just need to use this paginator.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;paginator = CachingPaginator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we have done that, it will be slow when we first time load the page and it will be faster afterwards. We can also fetch and cache this value from time to time. This solution might not get us the exact count and thus mess up pagination sometimes but in most cases that would not be much
of a problem.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Django Channels: Using Custom Channels</title>
      <link>http://masnun.rocks/2016/11/27/django-channels-using-custom-channels/</link>
      <pubDate>Sun, 27 Nov 2016 07:48:51 +0600</pubDate>
      
      <guid>http://masnun.rocks/2016/11/27/django-channels-using-custom-channels/</guid>
      <description>

&lt;p&gt;In my earlier blog post - &lt;a href=&#34;http://masnun.rocks/2016/09/25/introduction-to-django-channels/&#34;&gt;Introduction to Django Channels&lt;/a&gt;,
I mentioned that we can create our own channels for various purposes. In this blog post, we would discuss where custom channels
can be useful, what could be the challenges and of course we would see some code examples. But before we begin, please make sure
you are familiar with the concepts of Django Channels. I would recommend going through the above mentioned post and the official
docs to familiarize yourself with the basics.&lt;/p&gt;

&lt;h3 id=&#34;our-use-case&#34;&gt;Our Use Case&lt;/h3&gt;

&lt;p&gt;Channels is just a queue which has consumers (workers) listenning to it. With that concept in mind, we might be able to think of
many innovative use cases a queue could have. But in our example, we will keep the idea simple. We are going to use Channels as
a means of background task processing.&lt;/p&gt;

&lt;p&gt;We will create our own channels for different tasks. There will be consumers waiting for messages on these channels. When we want to
do something in the background, we would pass it on the appropriate channels &amp;amp; the workers will take care of the tasks. For example,
we want to create a thumbnail of an user uploaded photo? We pass it to the &lt;code&gt;thumbnails&lt;/code&gt; channel. We want to send a confirmation email,
we send it to the &lt;code&gt;welcome_email&lt;/code&gt; channel. Like that. If you are familiar with Celery or Python RQ, this would sound pretty
familiar to you.&lt;/p&gt;

&lt;p&gt;Now here&amp;rsquo;s my use case - in one of the projects I am working on, we&amp;rsquo;re building APIs for mobile applications. We use BrainTree for
payment integration. The mobile application sends a &lt;code&gt;nonce&lt;/code&gt; - it&amp;rsquo;s like a token that we can use to initiate the actual transaction.
The transaction has two steps - first we initiate it using the nonce and I get back a transaction id. Then I query whether the transaction
succeeded or failed. I felt it would be a good idea to process this in the background. We already have a websocket end point implemented
using Channels. So I thought it would be great to leverage the existing setup instead of introducing something new in the stack.&lt;/p&gt;

&lt;h3 id=&#34;challenges&#34;&gt;Challenges&lt;/h3&gt;

&lt;p&gt;It has so far worked pretty well. But we have to remember that Channels does not gurantee delivery of the messages and there is
no retrying if a message fails. So we wrote a custom management command that checks the orders for any records that have the nonce
set but no transaction id or there is transaction id but there is no final result stored. We then scheduled this command to run at
a certain interval and queue up the unfinished/incomplete orders again. In our case, it doesn&amp;rsquo;t hurt if the orders need some 5 to 10
minutes to process.&lt;/p&gt;

&lt;p&gt;But if we were working on a product where the message delivery was time critical for our business, we probably would have considered
Celery for the background processing part.&lt;/p&gt;

&lt;h3 id=&#34;let-s-see-the-codes&#34;&gt;Let&amp;rsquo;s see the codes!&lt;/h3&gt;

&lt;p&gt;First we needed to write a handler. The hadler would receive the messages on the subscribed channel and process them. Here&amp;rsquo;s the handler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def braintree_process(message):
    order_data = message.content.get(&#39;order&#39;)
    order_id = message.content.get(&#39;order_id&#39;)
    order_instance = Order.objects.get(pk=order_id)

    if order_data:
        nonce = order_data.get(&amp;quot;braintree_nonce&amp;quot;)
        if nonce:
            # [snipped]

            TRANSACTION_SUCCESS_STATUSES = [
                braintree.Transaction.Status.Authorized,
                braintree.Transaction.Status.Authorizing,
                braintree.Transaction.Status.Settled,
                braintree.Transaction.Status.SettlementConfirmed,
                braintree.Transaction.Status.SettlementPending,
                braintree.Transaction.Status.Settling,
                braintree.Transaction.Status.SubmittedForSettlement
            ]

            result = braintree.Transaction.sale({
                &#39;amount&#39;: str(order_data.get(&#39;total&#39;)),
                &#39;payment_method_nonce&#39;: nonce,
                &#39;options&#39;: {
                    &amp;quot;submit_for_settlement&amp;quot;: True
                }
            })

            if result.is_success or result.transaction:
                transaction = braintree.Transaction.find(result.transaction.id)
                if transaction.status in TRANSACTION_SUCCESS_STATUSES:
                    # [snipped]
                else:
                    # [snipped]
            else:
                errors = []
                for x in result.errors.deep_errors:
                    errors.append(str(x.code))

                # [snipped]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we needed to define a routing so the messages on a certain channel is passed on to this handler. So in our channel routing, we added
this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from channels.routing import route
from .channel_handlers import braintree_process

channel_routing = [
    route(&amp;quot;braintree_process&amp;quot;, braintree_process),
    # [snipped] ...
]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have a routing set and a handler ready to accept messages. So we&amp;rsquo;re ready! All we need to do is to start passing the
data to this channel.&lt;/p&gt;

&lt;p&gt;When the API receives a &lt;code&gt;nonce&lt;/code&gt;, it just passes the order details to this channel:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Channel(&amp;quot;braintree_process&amp;quot;).send({
    &amp;quot;order&amp;quot;: data,
    &amp;quot;order_id&amp;quot;: order.id
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then the workers start working. They accept the message and then starts processing the payment request.&lt;/p&gt;

&lt;p&gt;In our case, we already had the workers running (since they were serving our websocket requests). If you don&amp;rsquo;t have any workers running,
don&amp;rsquo;t forget to run them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py runworker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are wondering about how to deploy channels, I have you covered - &lt;a href=&#34;http://masnun.rocks/2016/11/02/deploying-django-channels-using-daphne/&#34;&gt;Deploying Django Channels using Daphne&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;prioritizing-scaling-channels&#34;&gt;Prioritizing / Scaling Channels&lt;/h3&gt;

&lt;p&gt;In our project, Django Channels do two things - handling websocket connections for realtime communication, process delayed jobs in
background. As you can probably guess, the realtime part is more important. In our current setup, the running workers handle both
types of requests as they come. But we want to dedicate more workers to the websocket and perhaps just one worker should keep processing
the payments.&lt;/p&gt;

&lt;p&gt;Luckily, we can limit our workers to certain channels using the &lt;code&gt;--only-channels&lt;/code&gt; flag. Or alternatively we can exclude certain
channels by using the &lt;code&gt;--exclude-channels&lt;/code&gt; flags.&lt;/p&gt;

&lt;h3 id=&#34;concluding-thoughts&#34;&gt;Concluding Thoughts&lt;/h3&gt;

&lt;p&gt;I personally find the design of channels very straightforward, simple and easy to reason about. When Channels get merged into Django,
it&amp;rsquo;s going to be quite useful, not just for implementing http/2 or websockets, but also as a way to process background tasks with ease
and without introducing third party libraries.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deploying Django Channels using Daphne</title>
      <link>http://masnun.rocks/2016/11/02/deploying-django-channels-using-daphne/</link>
      <pubDate>Wed, 02 Nov 2016 07:07:09 +0600</pubDate>
      
      <guid>http://masnun.rocks/2016/11/02/deploying-django-channels-using-daphne/</guid>
      <description>

&lt;p&gt;In one of my &lt;a href=&#34;http://masnun.rocks/2016/09/25/introduction-to-django-channels/&#34;&gt;earlier post&lt;/a&gt;, we
have seen an overview of how Django Channels work and how it helps us build cool stuff. However, in that post,
we covered deployment briefly. So here in this post, we shall go over deployment again, with a little more details
and of course code samples.&lt;/p&gt;

&lt;h3 id=&#34;what-do-we-need&#34;&gt;What do we need?&lt;/h3&gt;

&lt;p&gt;For running Django Channels, we would use the following setup:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nginx as the proxy&lt;/li&gt;
&lt;li&gt;daphne as the interface server&lt;/li&gt;
&lt;li&gt;redis as the backend&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s get started.&lt;/p&gt;

&lt;h3 id=&#34;setup-redis-and-configure-app&#34;&gt;Setup Redis and Configure App&lt;/h3&gt;

&lt;p&gt;We need to setup redis if it&amp;rsquo;s not installed already. Here&amp;rsquo;s how to do it on Ubuntu:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install redis-server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to use the redis backend, we also need to setup &lt;code&gt;asgi-redis&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install asgi_redis
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In your &lt;code&gt;settings.py&lt;/code&gt; file, make sure you used redis as the backend and input the host properly.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a demo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CHANNEL_LAYERS = {
    &amp;quot;default&amp;quot;: {
        &amp;quot;BACKEND&amp;quot;: &amp;quot;asgi_redis.RedisChannelLayer&amp;quot;,
        &amp;quot;CONFIG&amp;quot;: {
            &amp;quot;hosts&amp;quot;: [(&amp;quot;localhost&amp;quot;, 6379)],
        },
        &amp;quot;ROUTING&amp;quot;: &amp;quot;realtime.routing.channel_routing&amp;quot;,
    },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;starting-daphne&#34;&gt;Starting Daphne&lt;/h3&gt;

&lt;p&gt;If you have installed &lt;code&gt;channels&lt;/code&gt; from pip, you should have the &lt;code&gt;daphne&lt;/code&gt; command available already. In the very
unlikely case you don&amp;rsquo;t have it installed, here&amp;rsquo;s the command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install daphne
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To run daphne, we use the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;daphne -b 0.0.0.0 -p 8001 &amp;lt;app&amp;gt;.asgi:channel_layer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Daphne will bind to &lt;code&gt;0.0.0.0&lt;/code&gt; and use &lt;code&gt;8001&lt;/code&gt; as the port.&lt;/p&gt;

&lt;p&gt;Here &lt;code&gt;&amp;lt;app&amp;gt;&lt;/code&gt; is our app name / the module that contains the &lt;code&gt;asgi.py&lt;/code&gt; file. Please refer to the previous blog post
to know what we put in the &lt;code&gt;asgi.py&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;We now need to make sure &lt;code&gt;daphne&lt;/code&gt; is automatically started at system launch and restarted when it crashes. In this
example, I would stick to my old upstart script. But you would probably want to explore excellent projects like
&lt;code&gt;circus&lt;/code&gt; or &lt;code&gt;supervisor&lt;/code&gt; or at least &lt;code&gt;systemd&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the upstart script I use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;start on runlevel [2345]
stop on runlevel [016]

respawn

script
    cd /home/ubuntu/&amp;lt;app home&amp;gt;
    export DJANGO_SETTINGS_MODULE=&amp;quot;&amp;lt;app&amp;gt;.production_settings&amp;quot;
    exec daphne -b 0.0.0.0 -p 8001 &amp;lt;app&amp;gt;.asgi:channel_layer
end script

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;running-workers&#34;&gt;Running Workers&lt;/h3&gt;

&lt;p&gt;We need at least one running worker before daphne can start processing requests. To run a worker, we use the
following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py runworker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;runworker&lt;/code&gt; command spawns one worker with one thread. We should have more than one ideally. It is recommended
to have &lt;code&gt;n&lt;/code&gt; number of workers where &lt;code&gt;n&lt;/code&gt; is the number of available cpu cores.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a simple upstart script to keep the worker running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;start on runlevel [2345]
stop on runlevel [016]

respawn

script
    cd /home/ubuntu/&amp;lt;app home&amp;gt;
    export DJANGO_SETTINGS_MODULE=&amp;quot;&amp;lt;app&amp;gt;.production_settings&amp;quot;
    exec python3 manage.py runworker
end script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It would be much easier to launch multiple workers if you use supervisord or circus.&lt;/p&gt;

&lt;h3 id=&#34;nginx-conf&#34;&gt;Nginx Conf&lt;/h3&gt;

&lt;p&gt;Finally here&amp;rsquo;s the nginx conf I use. Please note I handle all incoming requests with daphne which is probably
not ideal. You can keep using &lt;code&gt;uwsgi&lt;/code&gt; for your existing, non real time parts and only handle the real time part
with daphne. Since setting up wsgi is popular knowledge, I will just focus on what we need for daphne.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
    listen 80;
    client_max_body_size 20M;

    location /static {
       	alias /home/ubuntu/&amp;lt;app home&amp;gt;/static;

    }

    location /media {
        alias /home/ubuntu/&amp;lt;app home&amp;gt;/media;

    }

    location / {


       	    proxy_pass http://0.0.0.0:8001;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection &amp;quot;upgrade&amp;quot;;

            proxy_redirect     off;
            proxy_set_header   Host $host;
            proxy_set_header   X-Real-IP $remote_addr;
            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header   X-Forwarded-Host $server_name;

        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have our daphne server running on port &lt;code&gt;8001&lt;/code&gt; so we set a proxy to that url. Now if daphne and worker are
running, we should be able to see our webpage when we visit the url.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to Django Channels</title>
      <link>http://masnun.rocks/2016/09/25/introduction-to-django-channels/</link>
      <pubDate>Sun, 25 Sep 2016 21:27:34 +0600</pubDate>
      
      <guid>http://masnun.rocks/2016/09/25/introduction-to-django-channels/</guid>
      <description>

&lt;p&gt;Django is a brilliant web framework. In fact it is my most favourite one for various reasons. An year and
a half ago, I switched to Python and Django for all my web development. I am a big fan of the eco system
and the many third party packages. Particularly I use Django REST Framework whenever I need to create
APIs. Having said that, Django was more than good enough for basic HTTP requests. But the web has changed.
We now have HTTP/2 and web sockets. Django could not support them well in the past. For the web socket part,
I usually had to rely on Tornado or NodeJS (with the excellent Socket.IO library). They are good technologies
but most of my web apps being in Django, I really wished there were something that could work with Django itself.
And then we had &lt;strong&gt;Channels&lt;/strong&gt;. The project is meant to allow Django to support HTTP/2, websockets or other
protocols with ease.&lt;/p&gt;

&lt;h3 id=&#34;concepts&#34;&gt;Concepts&lt;/h3&gt;

&lt;p&gt;The underlying concept is really simple - there are &lt;code&gt;channels&lt;/code&gt; and there are &lt;code&gt;messages&lt;/code&gt;,
there are &lt;code&gt;producers&lt;/code&gt; and there are &lt;code&gt;consumers&lt;/code&gt; - the whole system is based on passing messages
on to channels and consuming/responding to those messages.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at the core components of Django Channels first:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;channel&lt;/code&gt; - A channel is a FIFO queue like data structure. We can have many channels depending on our need.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;message&lt;/code&gt; - A message contains meaningful data for the consumers. Messages are passed on to the channels.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;consumer&lt;/code&gt; - A consumer is usually a function that consumes a message and take actions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;interface server&lt;/code&gt; - The interface server knows how to handle different protocols. It works as a translator
or a bridge between Django and the outside world.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;how-does-it-work&#34;&gt;How does it work?&lt;/h3&gt;

&lt;p&gt;A http request first comes to the &lt;code&gt;Interface Server&lt;/code&gt; which knows how to deal with a specific type of
request. For example, for websockets and http, &lt;strong&gt;Daphne&lt;/strong&gt; is a popular interface server. When a
new http/websocket request comes to the interface server (daphne in our case), it accepts the  request
and transforms it into a &lt;code&gt;message&lt;/code&gt;.  Then it passes the &lt;code&gt;message&lt;/code&gt; to the appropriate &lt;code&gt;channel&lt;/code&gt;. There are
predefined channels for specific types. For example, all http requests are passed to &lt;code&gt;http.request&lt;/code&gt; channel.
For incoming websocket messages, there is &lt;code&gt;websocket.receive&lt;/code&gt;. So these channels receive the messages when
the corresponding type of requests come in to the interface server.&lt;/p&gt;

&lt;p&gt;Now that we have &lt;code&gt;channels&lt;/code&gt; getting filled with &lt;code&gt;messages&lt;/code&gt;, we need a way to process these messages and
take actions (if necessary), right? Yes! For that we write some consumer functions and register them to
the channels we want. When messages come to these channels, the consumers are called with the message.
They can read the message and act on them.&lt;/p&gt;

&lt;p&gt;So far, we have seen how we can &lt;strong&gt;read&lt;/strong&gt; an incoming request. But like all web applications, we should
&lt;strong&gt;write&lt;/strong&gt; something back too, no? How do we do that? As it happens, the interface server is quite clever.
While transforming the incoming request into a message, it creates a &lt;code&gt;reply&lt;/code&gt; channel for that particular
client request and registers itself to that channel. Then it passes the reply channel along with the message.
When our consumer function reads the incoming message, it can pass a response to the &lt;code&gt;reply channel&lt;/code&gt; attached
with the message. Our interface server is listenning to that reply channel, remember? So when a response is sent
back to the reply channel, the interface server grabs the message, transforms it into a http response and sends
back to the client. Simple, no?&lt;/p&gt;

&lt;h3 id=&#34;writing-a-websocket-echo-server&#34;&gt;Writing a Websocket Echo Server&lt;/h3&gt;

&lt;p&gt;Enough with the theories, let&amp;rsquo;s get our hands dirty and build a simple echo server. The concept is simple.
The server accepts websocket connections, the client writes something to us, we just echo it back. Plain and
simple example.&lt;/p&gt;

&lt;h5 id=&#34;install-django-channels&#34;&gt;Install Django &amp;amp; Channels&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install channels
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That should do the trick and install Django + Channels. Channels has Django as a depdency, so when you install
channels, Django comes with it.&lt;/p&gt;

&lt;h5 id=&#34;create-an-app&#34;&gt;Create An App&lt;/h5&gt;

&lt;p&gt;Next we create a new django project and app -&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;django-admin.py startproject djchan
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd djchan
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python manage.py startapp realtime
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;configure-installed-apps&#34;&gt;Configure &lt;code&gt;INSTALLED_APPS&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;We have our Django app ready. We need to add &lt;code&gt;channels&lt;/code&gt; and our django app (&lt;code&gt;realtime&lt;/code&gt;) to the &lt;code&gt;INSTALLED_APPS&lt;/code&gt; list under &lt;code&gt;settings.py&lt;/code&gt;.
Let&amp;rsquo;s do that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;INSTALLED_APPS = [
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,

    &amp;quot;channels&amp;quot;,
    &amp;quot;realtime&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;write-our-consumer&#34;&gt;Write our Consumer&lt;/h5&gt;

&lt;p&gt;After that, we need to start writing a consumer function that will process the incoming websocket messages
and send back the response:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# consumers.py 
def websocket_receive(message):
    text = message.content.get(&#39;text&#39;)
    if text:
        message.reply_channel.send({&amp;quot;text&amp;quot;: &amp;quot;You said: {}&amp;quot;.format(text)})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code is simple enough. We receieve a message, get it&amp;rsquo;s text content (we&amp;rsquo;re expecting that the websocket
connection will send only text data for this exmaple) and then push it back to the &lt;code&gt;reply_channel&lt;/code&gt; - just like
we planned.&lt;/p&gt;

&lt;h5 id=&#34;channels-routing&#34;&gt;Channels Routing&lt;/h5&gt;

&lt;p&gt;We have our consume function ready, now we need to tell Django how to route messages to our consumer. Just like
URL routing, we need to define our channel routings.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# routing.py
from channels.routing import route
from .consumers import websocket_receive
 
channel_routing = [
    route(&amp;quot;websocket.receive&amp;quot;, websocket_receive, path=r&amp;quot;^/chat/&amp;quot;),
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code should be self explanatory. We have a list of &lt;code&gt;route&lt;/code&gt; objects. Here we select the channel name
(&lt;code&gt;websocket.receive&lt;/code&gt; =&amp;gt; for receieving websocket messages), pass the consumer function and then configure
the optional &lt;code&gt;path&lt;/code&gt;. The path is an interesting bit. If we didn&amp;rsquo;t pass a value for it, the consumer will
get all the messages in the &lt;code&gt;websocket.receive&lt;/code&gt; channel on any URL. So if someone created a websocket connection
to &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;/private&lt;/code&gt; or &lt;code&gt;/user/1234&lt;/code&gt; - regardless of the url path, we would get all incoming messages. But
that&amp;rsquo;s not our intention, right? So we restrict the &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;/chat&lt;/code&gt; so only connections made to that url
are handled by the consumer. Please note the beginning &lt;code&gt;/&lt;/code&gt;, unlike url routing, in channels, we have to use it.&lt;/p&gt;

&lt;h5 id=&#34;configuring-the-channel-layers&#34;&gt;Configuring The Channel Layers&lt;/h5&gt;

&lt;p&gt;We have defined a consumer and added it to a routing table. We&amp;rsquo;re more or less ready. There&amp;rsquo;s just a final
bit of configuration we need to do. We need to tell channels two things - which backend we want to use and
where it can find our channel routing.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s briefly talk about the backend. The messages and the channels - Django needs some sort of data store or
message queue to back this system. By default Django can use in memory backend which keeps these things in memory
but if you consider a distributed app, for scaling large, you need something else. Redis is a popular and proven
piece of technology for these kinds of scenarios. In our case we would use the Redis backend.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s install that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pip install asgi_redis
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we put this in our &lt;code&gt;settings.py&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;CHANNEL_LAYERS = {
    &amp;quot;default&amp;quot;: {
        &amp;quot;BACKEND&amp;quot;: &amp;quot;asgi_redis.RedisChannelLayer&amp;quot;,
        &amp;quot;CONFIG&amp;quot;: {
            &amp;quot;hosts&amp;quot;: [(&amp;quot;localhost&amp;quot;, 6379)],
        },
        &amp;quot;ROUTING&amp;quot;: &amp;quot;realtime.routing.channel_routing&amp;quot;,
    },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;running-the-servers&#34;&gt;Running The Servers&lt;/h5&gt;

&lt;p&gt;Make sure that Redis is running (usually &lt;code&gt;redis-server&lt;/code&gt; should run it). Now run the django app:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;python manage.py runserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In local environment, when you do &lt;code&gt;runserver&lt;/code&gt; - Django launches both the interface server and necessary
 background workers (to run the consumer functions in the background). But in production,
 we should run the workers seperately. We will get to that soon.&lt;/p&gt;

&lt;h5 id=&#34;trying-it-out&#34;&gt;Trying it Out!&lt;/h5&gt;

&lt;p&gt;Once our dev server starts up, let’s open up the web app. If you haven’t added any django views,
no worries, you should still see the “It Worked!” welcome page of Django and that should be
fine for now. We need to test our websocket and we are smart enough to do that from the dev console.
Open up your Chrome Devtools (or Firefox | Safari | any other browser’s dev tools) and navigate to the
JS console. Paste the following JS code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
socket = new WebSocket(&amp;quot;ws://&amp;quot; + window.location.host + &amp;quot;/chat/&amp;quot;);
socket.onmessage = function(e) {
    alert(e.data);
}
socket.onopen = function() {
    socket.send(&amp;quot;hello world&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything worked, you should get an alert with the message we sent. Since we defined a path,
the websocket connection works only on /chat/. Try modifying the JS code and send a message to
some other url to see how they don’t work. Also remove the path from our route and see how you can catch
all websocket messages from all the websocket connections regardless of which url they were connected to.
Cool, no?&lt;/p&gt;

&lt;h5 id=&#34;our-custom-channels&#34;&gt;Our Custom Channels&lt;/h5&gt;

&lt;p&gt;We have seen that certain protocols have predefined channels for various purposes. But we are not limited to those.
We can create our own channels. We don&amp;rsquo;t need to do anything fancy to initialize a new channel. We just need to
mention a name and send some messages to it. Django will create the channel for us.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Channel(&amp;quot;thumbnailer&amp;quot;).send({
        &amp;quot;image_id&amp;quot;: image.id
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course we need corresponding workers to be listenning to those channels. Otherwise nothing will happen.
Please note that besides working with new protocols, Channels also allow us to create some sort of message
based task queues. We create channels for certain tasks and our workers listen to those channels. Then we
pass the data to those channels and the workers process them. So for simpler tasks, this could be a nice
solution.&lt;/p&gt;

&lt;h3 id=&#34;scaling-production-systems&#34;&gt;Scaling Production Systems&lt;/h3&gt;

&lt;h5 id=&#34;running-workers-seperately&#34;&gt;Running Workers Seperately&lt;/h5&gt;

&lt;p&gt;On a production environment, we would want to run the workers seperately (since we would not run &lt;code&gt;runserver&lt;/code&gt; on
production anyway). To run the background workers, we have to run this command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;python manage.py runworker
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;asgi-daphne&#34;&gt;ASGI &amp;amp; Daphne&lt;/h5&gt;

&lt;p&gt;In our local environment, the &lt;code&gt;runserver&lt;/code&gt; command took care of launching the Interface server and background
workers. But now we have to run the interface server ourselves. We mentioned &lt;strong&gt;Daphne&lt;/strong&gt; already. It works
with the &lt;code&gt;ASGI&lt;/code&gt; standard (which is commonly used for HTTP/2 and websockets). Just like &lt;code&gt;wsgi.py&lt;/code&gt;, we now need to
create a &lt;code&gt;asgi.py&lt;/code&gt; module and configure it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
from channels.asgi import get_channel_layer

os.environ.setdefault(&amp;quot;DJANGO_SETTINGS_MODULE&amp;quot;, &amp;quot;djchan.settings&amp;quot;)

channel_layer = get_channel_layer()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can run the server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;daphne djchan.asgi:channel_layer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything goes right, the interface server should start running!&lt;/p&gt;

&lt;h5 id=&#34;asgi-or-wsgi&#34;&gt;ASGI or WSGI&lt;/h5&gt;

&lt;p&gt;ASGI is still new and WSGI is a battle tested http server. So you might still want to keep using wsgi for your
http only parts and asgi for the parts where you need channels specific features.&lt;/p&gt;

&lt;p&gt;The popular recommendation is that you should use &lt;code&gt;nginx&lt;/code&gt; or any other reverse proxies in front and route the
urls to asgi or uwsgi depending on the url or &lt;code&gt;Upgrade: WebSocket&lt;/code&gt; header.&lt;/p&gt;

&lt;h5 id=&#34;retries-and-celery&#34;&gt;Retries and Celery&lt;/h5&gt;

&lt;p&gt;The Channels system does not gurantee delivery. If there are tasks which needs the certainity, it is highly
recommended to use a system like Celery for these parts. Or we can also roll our own checks and retry logic if
we feel like that.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>